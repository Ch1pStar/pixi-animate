{"version":3,"sources":["../../src/animate/MovieClip.js"],"names":["Container","PIXI","SharedTicker","ticker","shared","MovieClip","options","duration","loop","framerate","labels","undefined","mode","INDEPENDENT","startPosition","frameSkip","Object","assign","currentFrame","_labels","_labelDict","name","label","position","push","sort","a","b","selfAdvance","paused","actionsEnabled","autoReset","_synchOffset","_prevPos","_t","_framerate","_duration","_totalFrames","_frameSkip","_timelines","_timedChildTimelines","_depthSorted","_actions","_beforeUpdate","_tickListener","bind","_onAdded","_onRemoved","on","advance","_updateTimeline","_setTimelinePosition","_goto","parentFramerate","add","tickerDeltaTime","seconds","speed","settings","TARGET_FPMS","remove","_autoExtend","endFrame","_parseProperties","properties","t","hexToUint","v","_getChildTimeline","instance","i","length","target","timeline","addTimedMask","keyframes","addKeyframe","m","parseInt","am","addTween","startFrame","ease","at","addTimedChild","SYNCHED","parentStartPosition","fillFrames","deserializeKeyframes","lastFrame","extendLastFrame","aa","callback","addAction","index","actions","ps","alias","playSound","animate","sound","emit","play","stop","gotoAndPlay","positionOrLabel","gotoAndStop","time","Math","floor","afterUpdateOnce","pos","NaN","_reset","synched","SINGLE_FRAME","doActions","j","tween","setPosition","timedChildTimelines","depthSorted","shouldBeChild","parent","addChild","removeChild","currentIndex","children","indexOf","addChildAt","child","needsLoop","min","frameActions","call","destroy","destroyChildren","hiddenChildren","timelines","_currentProps","current","len","value","o","fps","DEFAULT_FRAMERATE","extend","e","prototype","create","__parent","constructor"],"mappings":"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","file":"MovieClip.js","sourcesContent":["import Timeline from './Timeline';\r\nimport utils from './utils';\r\n\r\nconst Container = PIXI.Container;\r\nconst SharedTicker = PIXI.ticker.shared;\r\n\r\n/**\r\n * Provide timeline playback of movieclip\r\n * @memberof PIXI.animate\r\n * @class MovieClip\r\n * @extends PIXI.Container\r\n * @constructor\r\n * @param {Object|int} [options] The options object or the mode to play\r\n * @param {int} [options.mode=0] The playback mode default is independent (0),\r\n * @param {int} [options.startPosition=0] The starting frame\r\n * @param {Boolean} [options.loop=true] If playback is looped\r\n * @param {Object} [options.labels] The frame labels map of label to frames\r\n * @param {int} [options.duration] The duration, if no duration is provided, auto determines length\r\n * @param {int} [options.framerate=24] The framerate to use for independent mode\r\n */\r\nclass MovieClip extends Container {\r\n    constructor(options, duration, loop, framerate, labels) {\r\n        super();\r\n\r\n        // Default options\r\n        options = options === undefined ? {} : options;\r\n\r\n        // Options can also be the mode\r\n        if (typeof options === 'number') {\r\n            options = {\r\n                mode: options || MovieClip.INDEPENDENT,\r\n                duration: duration || 0,\r\n                loop: loop === undefined ? true : loop,\r\n                labels: labels || {},\r\n                framerate: framerate || 0,\r\n                startPosition: 0,\r\n                frameSkip: false,\r\n            };\r\n        } else {\r\n            // Apply defaults to options\r\n            options = Object.assign({\r\n                mode: MovieClip.INDEPENDENT,\r\n                startPosition: 0,\r\n                loop: true,\r\n                labels: {},\r\n                duration: 0,\r\n                framerate: 0\r\n            }, options);\r\n        }\r\n\r\n        /**\r\n         * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\r\n         * See each constant for a description of the behaviour.\r\n         * @name PIXI.animate.MovieClip#mode\r\n         * @type int\r\n         * @default null\r\n         */\r\n        this.mode = options.mode;\r\n\r\n        /**\r\n         * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\r\n         * @name PIXI.animate.MovieClip#startPosition\r\n         * @type Number\r\n         * @default 0\r\n         */\r\n        this.startPosition = options.startPosition;\r\n\r\n        /**\r\n         * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\r\n         * @name PIXI.animate.MovieClip#loop\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.loop = !!options.loop;\r\n\r\n        /**\r\n         * The current frame of the movieclip.\r\n         * @name PIXI.animate.MovieClip#currentFrame\r\n         * @type Number\r\n         * @default 0\r\n         * @readOnly\r\n         */\r\n        this.currentFrame = 0;\r\n\r\n        /**\r\n         * The collection of private labels\r\n         * @name PIXI.animate.MovieClip#_labels\r\n         * @type Array\r\n         * @private\r\n         */\r\n        this._labels = [];\r\n\r\n        /**\r\n         * The collection of private labels\r\n         * @name PIXI.animate.MovieClip#_labelDict\r\n         * @type Object\r\n         * @private\r\n         */\r\n        this._labelDict = options.labels;\r\n        if (options.labels) {\r\n            for (let name in options.labels) {\r\n                let label = {\r\n                    label: name,\r\n                    position: options.labels[name]\r\n                };\r\n                this._labels.push(label);\r\n            }\r\n            this._labels.sort(function(a, b) {\r\n                return a.position - b.position;\r\n            });\r\n        }\r\n\r\n        /**\r\n         * If true, this movieclip will animate automatically whenever it is on the stage.\r\n         * @name PIXI.animate.MovieClip#selfAdvance\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.selfAdvance = true;\r\n\r\n        /**\r\n         * If true, the MovieClip's position will not advance when ticked.\r\n         * @name PIXI.animate.MovieClip#paused\r\n         * @type Boolean\r\n         * @default false\r\n         */\r\n        this.paused = false;\r\n\r\n        /**\r\n         * If true, actions in this MovieClip's tweens will be run when the playhead advances.\r\n         * @name PIXI.animate.MovieClip#actionsEnabled\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.actionsEnabled = true;\r\n\r\n        /**\r\n         * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\r\n         * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\r\n         * <br><br>\r\n         * For example, if you had a character animation with a 'body' child MovieClip instance\r\n         * with different costumes on each frame, you could set body.autoReset = false, so that\r\n         * you can manually change the frame it is on, without worrying that it will be reset\r\n         * automatically.\r\n         * @name PIXI.animate.MovieClip#autoReset\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.autoReset = true;\r\n\r\n        /**\r\n         * @name PIXI.animate.MovieClip#_synchOffset\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._synchOffset = 0;\r\n\r\n        /**\r\n         * @name PIXI.animate.MovieClip#_prevPos\r\n         * @type Number\r\n         * @default -1\r\n         * @private\r\n         */\r\n        this._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\r\n\r\n        /**\r\n         * Note - changed from default: When the MovieClip is framerate independent, this is the time\r\n         * elapsed from frame 0 in seconds.\r\n         * @name PIXI.animate.MovieClip#_t\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._t = 0;\r\n\r\n        /**\r\n         * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\r\n         * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\r\n         * framerate.\r\n         *\r\n         * @name PIXI.animate.MovieClip#_framerate\r\n         * @type {Number}\r\n         * @default 0\r\n         * @protected\r\n         */\r\n        this._framerate = options.framerate;\r\n\r\n        /**\r\n         * The total time in seconds for the animation. This is changed when setting the framerate.\r\n         * @name PIXI.animate.MovieClip#_duration\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._duration = 0;\r\n\r\n        /**\r\n         * The total duration in frames for the animation.\r\n         * @name PIXI.animate.MovieClip#_totalFrames\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._totalFrames = options.duration;\r\n\r\n        this._frameSkip = options.frameSkip;\r\n\r\n        /**\r\n         * Standard tween timelines for all objects. Each element in the _timelines array\r\n         * is a Timeline object - an array of tweens for one target, in order of occurrence.\r\n         * @name PIXI.animate.MovieClip#_timelines\r\n         * @type Array\r\n         * @protected\r\n         */\r\n        this._timelines = [];\r\n\r\n        /**\r\n         * Array of child timelines denoting if a child is actively a child of this movieclip\r\n         * on any given frame. Each element in the _timedChildTimelines is an array with a 'target'\r\n         * property, and is an array of boolean values indexed by frame.\r\n         * @name PIXI.animate.MovieClip#_timedChildTimelines\r\n         * @type {Array}\r\n         * @protected\r\n         */\r\n        this._timedChildTimelines = [];\r\n\r\n        /**\r\n         * Array to depth sort timed children\r\n         * @name PIXI.animate.MovieClip#_depthSorted\r\n         * @type {Array}\r\n         * @private\r\n         */\r\n        this._depthSorted = [];\r\n\r\n        /**\r\n         * Array of frame scripts, indexed by frame.\r\n         * @name PIXI.animate.MovieClip#_actions\r\n         * @type {Array}\r\n         * @protected\r\n         */\r\n        this._actions = [];\r\n\r\n        /**\r\n         * Optional callback fired before timeline is updated.\r\n         * Can be used to clamp or update the currentFrame.\r\n         * @name PIXI.animate.MovieClip#_beforeUpdate\r\n         * @type {Function}\r\n         * @private\r\n         */\r\n        this._beforeUpdate = null;\r\n\r\n        if (this.mode === MovieClip.INDEPENDENT) {\r\n            this._tickListener = this._tickListener.bind(this);\r\n            this._onAdded = this._onAdded.bind(this);\r\n            this._onRemoved = this._onRemoved.bind(this);\r\n            this.on('added', this._onAdded);\r\n            this.on('removed', this._onRemoved);\r\n        }\r\n\r\n        if (options.framerate) {\r\n            this.framerate = options.framerate;\r\n        }\r\n\r\n        //save often used methods on the instance so that they can be fetched slightly faster\r\n        //than if they had to be fetched from the prototype\r\n        this.advance = this.advance;\r\n        this._updateTimeline = this._updateTimeline;\r\n        this._setTimelinePosition = this._setTimelinePosition;\r\n        this._goto = this._goto;\r\n    }\r\n\r\n    _onAdded() {\r\n        if (!this._framerate) {\r\n            this.framerate = this.parentFramerate;\r\n        }\r\n        SharedTicker.add(this._tickListener);\r\n    }\r\n\r\n    _tickListener(tickerDeltaTime) {\r\n        if (this.paused || !this.selfAdvance) {\r\n            //see if the movieclip needs to be updated even though it isn't animating\r\n            if (this._prevPos < 0) {\r\n                this._goto(this.currentFrame);\r\n            }\r\n            return;\r\n        }\r\n        let seconds = tickerDeltaTime / SharedTicker.speed / PIXI.settings.TARGET_FPMS / 1000;\r\n\r\n        this.advance(seconds);\r\n    }\r\n\r\n    _onRemoved() {\r\n        SharedTicker.remove(this._tickListener);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of objects with label and position (aka frame) properties, sorted by position.\r\n     * @name PIXI.animate.MovieClip#labels\r\n     * @type {Array}\r\n     * @readonly\r\n     */\r\n    get labels() {\r\n        return this._labels;\r\n    }\r\n\r\n    /**\r\n     * Returns a dictionary of labels where key is the label and value is the frame.\r\n     * @name PIXI.animate.MovieClip#labelsMap\r\n     * @type {Object}\r\n     * @readonly\r\n     */\r\n    get labelsMap() {\r\n        return this._labelDict;\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the label on or immediately before the current frame.\r\n     * @name PIXI.animate.MovieClip#currentLabel\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n    get currentLabel() {\r\n        let labels = this._labels;\r\n        let current = null;\r\n        for (let i = 0, len = labels.length; i < len; ++i) {\r\n            if (labels[i].position <= this.currentFrame) {\r\n                current = labels[i].label;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return current;\r\n    }\r\n\r\n    /**\r\n     * When the MovieClip is framerate independent, this is the time elapsed from frame 0 in seconds.\r\n     * @name PIXI.animate.MovieClip#elapsedTime\r\n     * @type Number\r\n     * @default 0\r\n     * @public\r\n     */\r\n    get elapsedTime() {\r\n        return this._t;\r\n    }\r\n\r\n    set elapsedTime(value) {\r\n        this._t = value;\r\n    }\r\n\r\n    /**\r\n     * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\r\n     * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\r\n     * framerate.\r\n     *\r\n     * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\r\n     * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\r\n     * vary slightly between frames.\r\n     *\r\n     * This feature is dependent on the tick event object (or an object with an appropriate 'delta' property) being\r\n     * passed into {{#crossLink 'Stage/update'}}{{/crossLink}}.\r\n     * @name PIXI.animate.MovieClip#framerate\r\n     * @type {Number}\r\n     * @default 0\r\n     */\r\n    get framerate() {\r\n        return this._framerate;\r\n    }\r\n    set framerate(value) {\r\n        if (value > 0) {\r\n            this._framerate = value;\r\n            this._duration = value ? this._totalFrames / value : 0;\r\n            this._t = this.currentFrame / value;\r\n        } else {\r\n            this._t = this._framerate = this._duration = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the total number of frames (duration) of this MovieClip\r\n     * @name PIXI.animate.MovieClip#totalFrames\r\n     * @type {Number}\r\n     * @default 0\r\n     * @readOnly\r\n     */\r\n    get totalFrames() {\r\n        return this._totalFrames;\r\n    }\r\n\r\n    /**\r\n     * Extend the timeline to the last frame.\r\n     * @method PIXI.animate.MovieClip#_autoExtend\r\n     * @private\r\n     * @param {int} endFrame\r\n     */\r\n    _autoExtend(endFrame) {\r\n        if (this._totalFrames < endFrame) {\r\n            this._totalFrames = endFrame;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert values of properties\r\n     * @method PIXI.animate.MovieClip#_parseProperties\r\n     * @private\r\n     * @param {Object} properties\r\n     */\r\n    _parseProperties(properties) {\r\n        // Convert any string colors to uints\r\n        if (typeof properties.t === 'string') {\r\n            properties.t = utils.hexToUint(properties.t);\r\n        } else if (typeof properties.v === 'number') {\r\n            properties.v = !!properties.v;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a timeline for a child, synced timeline.\r\n     * @method PIXI.animate.MovieClip#_getChildTimeline\r\n     * @private\r\n     * @param {PIXI.animate.MovieClip} instance\r\n     * @return {PIXI.animate.Timeline}\r\n     */\r\n    _getChildTimeline(instance) {\r\n        for (let i = this._timelines.length - 1; i >= 0; --i) {\r\n            if (this._timelines[i].target === instance) {\r\n                return this._timelines[i];\r\n            }\r\n        }\r\n        let timeline = new Timeline(instance);\r\n        this._timelines.push(timeline);\r\n        return timeline;\r\n    }\r\n\r\n    /**\r\n     * Add mask or masks\r\n     * @method PIXI.animate.MovieClip#addTimedMask\r\n     * @param {PIXI.DisplayObject} instance Instance to mask\r\n     * @param {Object} keyframes The map of frames to mask objects\r\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\r\n     */\r\n    addTimedMask(instance, keyframes) {\r\n        for (let i in keyframes) {\r\n            this.addKeyframe(instance, {\r\n                m: keyframes[i]\r\n            }, parseInt(i, 10));\r\n        }\r\n\r\n        // Set the initial position/add\r\n        this._setTimelinePosition(this.currentFrame, this.currentFrame, true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Shortcut alias for `addTimedMask`\r\n     * @method PIXI.animate.MovieClip#am\r\n     * @param {PIXI.DisplayObject} instance Instance to mask\r\n     * @param {Object} keyframes The map of frames to mask objects\r\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\r\n     */\r\n    am(instance, keyframes) {\r\n        return this.addTimedMask(instance, keyframes);\r\n    }\r\n\r\n    /**\r\n     * Add a tween to the clip\r\n     * @method PIXI.animate.MovieClip#addTween\r\n     * @param {PIXI.DisplayObject} instance The clip to tween\r\n     * @param {Object} properties The property or property to tween\r\n     * @param {int} startFrame The frame to start tweening\r\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\r\n     *                           with no tweening.\r\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addTween(instance, properties, startFrame, duration, ease) {\r\n\r\n        let timeline = this._getChildTimeline(instance);\r\n        this._parseProperties(properties);\r\n        timeline.addTween(properties, startFrame, duration, ease);\r\n        this._autoExtend(startFrame + duration);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a tween to the clip\r\n     * @method PIXI.animate.MovieClip#addKeyframe\r\n     * @param {PIXI.DisplayObject} instance The clip to tween\r\n     * @param {Object} properties The property or property to tween\r\n     * @param {int} startFrame The frame to start tweening\r\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\r\n     *                           with no tweening.\r\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addKeyframe(instance, properties, startFrame) {\r\n\r\n        let timeline = this._getChildTimeline(instance);\r\n        this._parseProperties(properties);\r\n        timeline.addKeyframe(properties, startFrame);\r\n        this._autoExtend(startFrame);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Alias for method `addTimedChild`\r\n     * @method PIXI.animate.MovieClip#at\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    at(instance, startFrame, duration, keyframes) {\r\n        return this.addTimedChild(instance, startFrame, duration, keyframes);\r\n    }\r\n\r\n    /**\r\n     * Add a child to show for a certain number of frames before automatic removal.\r\n     * @method PIXI.animate.MovieClip#addTimedChild\r\n     * @param {PIXI.DisplayObject} instance The clip to show\r\n     * @param {int} startFrame The starting frame\r\n     * @param {int} [duration=1] The number of frames to display the child before removing it.\r\n     * @param {String|Array} [keyframes] The collection of static keyframes to add\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addTimedChild(instance, startFrame, duration, keyframes) {\r\n\r\n        if (startFrame === undefined) // jshint ignore:line\r\n        {\r\n            startFrame = 0;\r\n        }\r\n        if (duration === undefined || duration < 1) // jshint ignore:line\r\n        {\r\n            duration = this._totalFrames || 1;\r\n        }\r\n\r\n        // Add the starting offset for synced movie clips\r\n        if (instance.mode === MovieClip.SYNCHED) {\r\n            instance.parentStartPosition = startFrame;\r\n        }\r\n\r\n        //add tweening info about this child's presence on stage\r\n        //when the child is (re)added, if it has 'autoReset' set to true, then it\r\n        //should be set back to frame 0\r\n        let timeline, i;\r\n        //get existing timeline\r\n        for (i = this._timedChildTimelines.length - 1; i >= 0; --i) {\r\n            if (this._timedChildTimelines[i].target === instance) {\r\n                timeline = this._timedChildTimelines[i];\r\n                break;\r\n            }\r\n        }\r\n        //if there wasn't one, make a new one\r\n        if (!timeline) {\r\n            timeline = [];\r\n            timeline.target = instance;\r\n            this._timedChildTimelines.push(timeline);\r\n        }\r\n\r\n        // Fill the timeline with keyframe booleans\r\n        utils.fillFrames(timeline, startFrame, duration);\r\n\r\n        // Update the total frames if the instance extends our current\r\n        // total frames for this movieclip\r\n        if (this._totalFrames < startFrame + duration) {\r\n            this._totalFrames = startFrame + duration;\r\n        }\r\n\r\n        // Add the collection of keyframes\r\n        if (keyframes) {\r\n            if (typeof keyframes === \"string\") {\r\n                keyframes = utils.deserializeKeyframes(keyframes);\r\n            }\r\n            // Convert the keyframes object into\r\n            // individual properties\r\n            let lastFrame = {};\r\n            for (let i in keyframes) {\r\n                lastFrame = Object.assign({}, lastFrame, keyframes[i]);\r\n                this.addKeyframe(instance, lastFrame, parseInt(i, 10));\r\n            }\r\n            this._getChildTimeline(instance)\r\n                .extendLastFrame(startFrame + duration);\r\n        }\r\n\r\n        // Set the initial position/add\r\n        this._setTimelinePosition(startFrame, this.currentFrame, true);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Short cut for `addAction`\r\n     * @method PIXI.animate.MovieClip#aa\r\n     * @param {Function} callback The clip call on a certain frame\r\n     * @param {int|String} startFrame The starting frame index or label\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    aa(callback, startFrame) {\r\n        return this.addAction(callback, startFrame);\r\n    }\r\n\r\n    /**\r\n     * Handle frame actions, callback is bound to the instance of the MovieClip.\r\n     * @method PIXI.animate.MovieClip#addAction\r\n     * @param {Function} callback The clip call on a certain frame\r\n     * @param {int|String} startFrame The starting frame index or label\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addAction(callback, startFrame) {\r\n\r\n        if (typeof startFrame === 'string') {\r\n            const index = this._labelDict[startFrame];\r\n            if (index === undefined) {\r\n                throw `The label '${startFrame}' does not exist on this timeline`;\r\n            }\r\n            startFrame = index;\r\n        }\r\n\r\n        let actions = this._actions;\r\n        //ensure that the movieclip timeline is long enough to support the target frame\r\n        if (actions.length <= startFrame) {\r\n            actions.length = startFrame + 1;\r\n        }\r\n        if (this._totalFrames < startFrame) {\r\n            this._totalFrames = startFrame;\r\n        }\r\n        //add the action\r\n        if (actions[startFrame]) {\r\n            actions[startFrame].push(callback);\r\n        } else {\r\n            actions[startFrame] = [callback];\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Short cut for `playSound`\r\n     * @method PIXI.animate.MovieClip#ps\r\n     * @param {String} alias The name of the Sound\r\n     * @param {Boolean} [loop=false] The loop property of the sound\r\n     * @param {MovieClip} context The MovieClip the sound originates from\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    ps(alias, loop) {\r\n        return this.playSound(alias, loop);\r\n    }\r\n\r\n    /**\r\n     * Handle sounds.\r\n     * @method PIXI.animate.MovieClip#playSound\r\n     * @param {String} alias The name of the Sound\r\n     * @param {Boolean} [loop=false] The loop property of the sound\r\n     * @param {MovieClip} context The MovieClip the sound originates from\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    playSound(alias, loop) {\r\n        PIXI.animate.sound.emit('play', alias, !!loop, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets paused to false.\r\n     * @method PIXI.animate.MovieClip#play\r\n     */\r\n    play() {\r\n        this.paused = false;\r\n    }\r\n\r\n    /**\r\n     * Sets paused to true.\r\n     * @method PIXI.animate.MovieClip#stop\r\n     */\r\n    stop() {\r\n        this.paused = true;\r\n    }\r\n\r\n    /**\r\n     * Advances this movie clip to the specified position or label and sets paused to false.\r\n     * @method PIXI.animate.MovieClip#gotoAndPlay\r\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\r\n     */\r\n    gotoAndPlay(positionOrLabel) {\r\n        this.paused = false;\r\n        this._goto(positionOrLabel);\r\n    }\r\n\r\n    /**\r\n     * Advances this movie clip to the specified position or label and sets paused to true.\r\n     * @method PIXI.animate.MovieClip#gotoAndStop\r\n     * @param {String|Number} positionOrLabel The animation or frame name to go to.\r\n     */\r\n    gotoAndStop(positionOrLabel) {\r\n        this.paused = true;\r\n        this._goto(positionOrLabel);\r\n    }\r\n\r\n    /**\r\n     * Get the close parent with a valid framerate. If no parent, returns the default framerate.\r\n     * @name PIXI.animate.MovieClip#parentFramerate\r\n     * @type {Number}\r\n     * @readOnly\r\n     */\r\n    get parentFramerate() {\r\n        let o = this,\r\n            fps = o._framerate;\r\n        while ((o = o.parent) && !fps) {\r\n            if (o.mode === MovieClip.INDEPENDENT) {\r\n                fps = o._framerate;\r\n            }\r\n        }\r\n        return fps || MovieClip.DEFAULT_FRAMERATE;\r\n    }\r\n\r\n    /**\r\n     * Advances the playhead. This occurs automatically each tick by default.\r\n     * @method PIXI.animate.MovieClip#advance\r\n     * @param [time] {Number} The amount of time in seconds to advance by. Only applicable if framerate is set.\r\n     */\r\n    advance(time) {\r\n\r\n        // Handle any other cases where starting to play\r\n        // and no framerate has been set yet\r\n        if (!this._framerate) {\r\n            this.framerate = this.parentFramerate;\r\n        }\r\n\r\n        if (time) {\r\n            this._t += time;\r\n        }\r\n\r\n        if (this._t > this._duration) {\r\n            this._t = this.loop ? this._t - this._duration : this._duration;\r\n        }\r\n\r\n        if(this._frameSkip) {\r\n            //add a tiny amount to account for potential floating point errors\r\n            this.currentFrame = Math.floor(this._t * this._framerate + 0.00000001);\r\n\r\n            //final error checking\r\n            if (this.currentFrame >= this._totalFrames) {\r\n                this.currentFrame = this._totalFrames - 1;\r\n            }\r\n        }else{\r\n            this.currentFrame = this.loop ? (this.currentFrame%this._totalFrames) + 1 : this.currentFrame + 1;\r\n        }\r\n\r\n        let afterUpdateOnce;\r\n        if (this._beforeUpdate) {\r\n            afterUpdateOnce = this._beforeUpdate(this);\r\n        }\r\n        //update all tweens & actions in the timeline\r\n        this._updateTimeline();\r\n\r\n        // Do the animator callback here\r\n        if (afterUpdateOnce) {\r\n            afterUpdateOnce();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method PIXI.animate.MovieClip#_goto\r\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\r\n     * @protected\r\n     */\r\n    _goto(positionOrLabel) {\r\n        let pos = typeof positionOrLabel === 'string' ? this._labelDict[positionOrLabel] : positionOrLabel;\r\n        if (pos === undefined) // jshint ignore:line\r\n        {\r\n            return;\r\n        }\r\n        // prevent _updateTimeline from overwriting the new position because of a reset:\r\n        this._prevPos = NaN;\r\n        this.currentFrame = pos;\r\n\r\n        // Handle the case where trying to play but haven't\r\n        // added to the stage yet\r\n        if (!this._framerate) {\r\n            this.framerate = this.parentFramerate;\r\n        }\r\n\r\n        //update the elapsed time if a time based movieclip\r\n        if (this._framerate > 0) {\r\n            this._t = pos / this._framerate;\r\n        } else {\r\n            this._t = 0;\r\n        }\r\n        this._updateTimeline();\r\n    }\r\n\r\n    /**\r\n     * @method PIXI.animate.MovieClip#_reset\r\n     * @private\r\n     */\r\n    _reset() {\r\n        this._prevPos = -1;\r\n        this._t = 0;\r\n        this.currentFrame = 0;\r\n    }\r\n\r\n    /**\r\n     * @method PIXI.animate.MovieClip#_updateTimeline\r\n     * @protected\r\n     */\r\n    _updateTimeline() {\r\n        let synched = this.mode !== MovieClip.INDEPENDENT;\r\n\r\n        if (synched) {\r\n            this.currentFrame = this.startPosition + (this.mode === MovieClip.SINGLE_FRAME ? 0 : this._synchOffset);\r\n            if (this.currentFrame >= this._totalFrames) {\r\n                this.currentFrame %= this._totalFrames;\r\n            }\r\n        }\r\n\r\n        if (this._prevPos === this.currentFrame) {\r\n            return;\r\n        }\r\n\r\n        // update timeline position, ignoring actions if this is a graphic.\r\n        this._setTimelinePosition(this._prevPos, this.currentFrame, synched ? false : this.actionsEnabled);\r\n\r\n        this._prevPos = this.currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Set the timeline position\r\n     * @method PIXI.animate.MovieClip#_setTimelinePosition\r\n     * @protected\r\n     * @param {int} startFrame\r\n     * @param {int} currentFrame\r\n     * @param {Boolean} doActions\r\n     */\r\n    _setTimelinePosition(startFrame, currentFrame, doActions) {\r\n        //handle all tweens\r\n        let i, j, length, _timelines = this._timelines;\r\n        for (i = _timelines.length - 1; i >= 0; --i) {\r\n            let timeline = _timelines[i];\r\n            for (j = 0, length = timeline.length; j < length; ++j) {\r\n                let tween = timeline[j];\r\n                //if the tween contains part of the timeline that we are travelling through\r\n                if (currentFrame >= tween.startFrame &&\r\n                    currentFrame <= tween.endFrame) {\r\n                    // set the position within that tween\r\n                    //and break the loop to move onto the next timeline\r\n                    tween.setPosition(currentFrame);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        let timedChildTimelines = this._timedChildTimelines;\r\n        let depthSorted = this._depthSorted;\r\n        for (i = 0, length = timedChildTimelines.length; i < length; ++i) {\r\n            let target = timedChildTimelines[i].target;\r\n            let shouldBeChild = timedChildTimelines[i][currentFrame];\r\n            //if child should be on stage and is not:\r\n            if (shouldBeChild) {\r\n                // Add to the depthSorted object so we can\r\n                // check that items are property drawn later\r\n                depthSorted.push(target);\r\n                if (target.parent !== this) {\r\n                    // add the target if it's not there already\r\n                    this.addChild(target);\r\n                    if (target.mode === MovieClip.INDEPENDENT && target.autoReset) {\r\n                        target._reset();\r\n                    }\r\n                }\r\n            } else if (!shouldBeChild && target.parent === this) {\r\n                this.removeChild(target);\r\n            }\r\n        }\r\n\r\n        // Properly depth sort the children\r\n        for (i = 0, length = depthSorted.length; i < length; i++) {\r\n            let target = depthSorted[i];\r\n            let currentIndex = this.children.indexOf(target);\r\n            if (currentIndex !== i) {\r\n                this.addChildAt(target, i);\r\n            }\r\n        }\r\n\r\n        // Clear the temporary depth sorting array\r\n        depthSorted.length = 0;\r\n\r\n        //go through all children and update synched movieclips that are not single frames\r\n        let children = this.children,\r\n            child;\r\n        for (i = 0, length = children.length; i < length; ++i) {\r\n            child = children[i];\r\n            if (child.mode === MovieClip.SYNCHED) {\r\n                child._synchOffset = currentFrame - child.parentStartPosition;\r\n                child._updateTimeline();\r\n            }\r\n        }\r\n\r\n        //handle actions\r\n        if (doActions) {\r\n            let actions = this._actions;\r\n            //handle looping around\r\n            let needsLoop = false;\r\n            if (currentFrame < startFrame) {\r\n                length = actions.length;\r\n                needsLoop = true;\r\n            } else {\r\n                length = Math.min(currentFrame + 1, actions.length);\r\n            }\r\n\r\n            for (i = startFrame >= 0 ? startFrame + 1 : currentFrame; i < length; ++i) {\r\n                if (actions[i]) {\r\n                    let frameActions = actions[i];\r\n                    for (j = 0; j < frameActions.length; ++j) {\r\n                        frameActions[j].call(this);\r\n                    }\r\n                }\r\n                //handle looping around\r\n                if (needsLoop && i === length - 1) {\r\n                    i = 0;\r\n                    length = currentFrame + 1;\r\n                    needsLoop = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    destroy(destroyChildren) {\r\n        if (this._tickListener) {\r\n            SharedTicker.remove(this._tickListener);\r\n            this._tickListener = null;\r\n        }\r\n        const hiddenChildren = [];\r\n        let timelines = this._timelines;\r\n        if (timelines) {\r\n            for (let i = 0; i < timelines.length; i++) {\r\n                const timeline = timelines[i];\r\n                hiddenChildren.push(timeline.target);\r\n                timeline._currentProps = null;\r\n                timeline.length = 0;\r\n            }\r\n        }\r\n        timelines = this._timedChildTimelines;\r\n        if (timelines) {\r\n            for (let i = 0; i < timelines.length; i++) {\r\n                const timeline = timelines[i];\r\n                if (hiddenChildren.indexOf(timeline.target) < 0) {\r\n                    hiddenChildren.push(timeline.target);\r\n                }\r\n                timeline._currentProps = null;\r\n                timeline.length = 0;\r\n            }\r\n        }\r\n        // Destroy all the children\r\n        for (let i = 0; i < hiddenChildren.length; i++) {\r\n            // Don't destroy children in the display list\r\n            if (this.children.indexOf(hiddenChildren[i]) < 0) {\r\n                hiddenChildren[i].destroy(destroyChildren);\r\n            }\r\n        }\r\n        hiddenChildren.length = 0;\r\n        this._actions = null;\r\n        this._timelines = null;\r\n        this._depthSorted = null;\r\n        this._timedChildTimelines = null;\r\n        this._beforeUpdate = null;\r\n        this._labels = null;\r\n        this._labelDict = null;\r\n        super.destroy(destroyChildren);\r\n    }\r\n}\r\n\r\n/**\r\n * The MovieClip will advance independently of its parent, even if its parent is paused.\r\n * This is the default mode.\r\n * @name PIXI.animate.MovieClip.INDEPENDENT\r\n * @static\r\n * @type String\r\n * @default 0\r\n * @readonly\r\n */\r\nMovieClip.INDEPENDENT = 0;\r\n\r\n/**\r\n * The MovieClip will only display a single frame (as determined by the startPosition property).\r\n * @name PIXI.animate.MovieClip.SINGLE_FRAME\r\n * @static\r\n * @type String\r\n * @default 1\r\n * @readonly\r\n */\r\nMovieClip.SINGLE_FRAME = 1;\r\n\r\n/**\r\n * The MovieClip will be advanced only when its parent advances and will be synched to the position of\r\n * the parent MovieClip.\r\n * @name PIXI.animate.MovieClip.SYNCHED\r\n * @static\r\n * @type String\r\n * @default 2\r\n * @readonly\r\n */\r\nMovieClip.SYNCHED = 2;\r\n\r\n\r\n/**\r\n * The default framerate if none is specified or there's not parent clip with a framerate.\r\n * @name PIXI.animate.MovieClip.DEFAULT_FRAMERATE\r\n * @static\r\n * @type Number\r\n * @default 24\r\n * @readonly\r\n */\r\nMovieClip.DEFAULT_FRAMERATE = 24;\r\n\r\n/**\r\n * Extend a container\r\n * @method PIXI.animate.MovieClip.extend\r\n * @static\r\n * @param {PIXI.animate.MovieClip} child The child function\r\n * @return {PIXI.animate.MovieClip} The child\r\n */\r\n/**\r\n * Extend a container (alias for `extend`)\r\n * @method PIXI.animate.MovieClip.e\r\n * @static\r\n * @param {PIXI.animate.MovieClip} child The child function\r\n * @return {PIXI.animate.MovieClip} The child\r\n */\r\nMovieClip.extend = MovieClip.e = function(child) {\r\n    child.prototype = Object.create(MovieClip.prototype);\r\n    child.prototype.__parent = MovieClip.prototype;\r\n    child.prototype.constructor = child;\r\n    return child;\r\n};\r\n\r\n// Assign to namespace\r\nexport default MovieClip;"]}